# Real-Time OS
实时操作系统（Real-Time Operating System，RTOS）是一种专门设计用于在严格的时间约束下执行任务的操作系统。它的核心特点是**实时性**，即确保任务在规定的时间内完成，而不会出现长时间的延迟。

- 实时操作系统的分类
1. 硬实时操作系统：必须保证所有任务在严格的时间限制内完成，否则可能会导致系统故障。例如，航空航天、医疗设备和工业控制系统。
2. 软实时操作系统：尽量保证任务在规定时间内完成，但偶尔的延迟不会导致系统崩溃。例如，视频流处理和在线游戏。

- 实时操作系统的特点
1. 任务调度：采用抢占式调度或时间触发调度，确保高优先级任务能够及时执行。
2. 低延迟：减少任务切换时间，提高系统响应速度。
3. 确定性：任务执行时间可预测，避免不确定性影响系统稳定性。
4. 资源管理：高效管理 CPU、内存和 I/O 设备，确保关键任务优先执行。

- 常见的实时操作系统
1. [FreeRTOS](#freertos)：开源、轻量级，适用于嵌入式系统。
2. VxWorks：广泛应用于航空航天和工业自动化领域。
3. RT-Thread：国产 RTOS，适用于物联网设备。
4. QNX：用于汽车、医疗和工业控制系统。
5. μC/OS-II：适用于小型嵌入式系统，代码精简。

- **什么是通用操作系统？**

操作系统是支持计算机基本功能的计算机程序， 为在计算机上运行的程序（或_应用程序_）提供服务。应用程序提供计算机用户 想要或需要的功能。操作系统提供的服务使得应用程序写入更快、更简单、 并且更易于维护。如果您正在阅读此网页，说明您正在使用网络浏览器（提供您感兴趣的功能的应用程序），该浏览器本身会在操作系统提供的环境中运行 。

- **什么是 RTOS？**

大多数操作系统似乎能同时执行多个程序。这称为多任务处理。实际上， 每个处理器内核在任何给定时间点都只能运行一个执行线程。操作系统中 一个名为调度器的部分负责决定何时运行哪个程序， 并通过在每个程序之间快速切换以造成同时执行的假象。

操作系统的类型取决于调度器如何决定何时运行哪个程序。例如， 多用户操作系统（如 Unix）中使用的调度器将确保每个用户都能获得合理的处理时间 。再比如，桌面操作系统（如 Windows）中的调度器会努力确保计算机对用户作出响应。 （注意：FreeRTOS 并非大型操作系统，也不是为在台式 计算机级处理器上运行而设计的，我使用这些例子纯粹是因为它们是读者熟悉的系统。）

实时操作系统中的调度器旨在提供 可预测的（通常描述为 _确定性_）执行模式。这对嵌入式系统而言意义重大，因为嵌入式系统 经常有实时要求。实时要求是指定嵌入式系统 必须在严格定义的时间内（_截止时间_）响应某个事件。只有当操作系统调度器的行为 可以预测（因此具有确定性）时， 才能保证满足实时要求。

传统的小型实时调度器（如 FreeRTOS 中使用的调度器） 通过允许用户为每个执行线程分配优先级来实现确定性。然后，调度器根据优先级来判断 下一个要运行的执行线程。在 FreeRTOS 中，执行线程称为 _任务_。

- **RTOS 基础知识**

实时操作系统 (RTOS) 是一种体积小巧、确定性强的计算机操作系统。 RTOS 通常用于需要在严格时间限制内对外部事件做出反应的嵌入式系统，如医疗设备和汽车电子控制单元 (ECU)。 通常，此类嵌入式系统中只有一两项功能需要确定性时序，即使嵌入式系统不需要严格的实时反应，使用 RTOS 仍能提供诸多优势。

RTOS 通常比通用操作系统体积更小、重量更轻，因此 RTOS 非常适用于 内存、计算和功率受限的设备。

1. **多任务处理**

**内核**是操作系统的核心组件。Linux 等通用操作系统采用的内核 允许多个用户看似同时访问计算机的处理器。这些用户可以各自执行多个程序，看起来像是并发运行。

每个执行的程序由操作系统控制下的一个或多个**线程**实现。如果操作系统能够以这种方式执行多个线程，则称为**多任务处理**。 像 FreeRTOS 这样的小型 RTOS 通常将线程称为**任务**，因为它们不支持虚拟内存，因此进程和线程之间没有区别。

使用多任务操作系统可以简化原本复杂的软件应用程序的设计：
- 操作系统的多任务处理和任务间通信功能允许将复杂的应用程序 划分为一组更小且更易于管理的任务。
- 这种划分可以简化软件测试，确保团队分工明确，并促进代码复用。
- 复杂的时序和排序细节将由 RTOS 内核负责，从而减轻了应用程序代码的负担。

2. **多任务处理与并发**

常规单核处理器一次只能执行一个任务，但多任务操作系统可以快速切换任务， 使所有任务**看起来**像是同时在执行。下图展示了 三个任务相对于时间的执行模式。任务名称用不同颜色标示，并写在左侧。时间从左向右移动， 彩色线条显示在特定时间执行的任务。上方展示了所感知的并发执行模式， 下方展示了实际的多任务执行模式。

![TaskExecution.gif](https://www.freertos.org/media/2018/TaskExecution.gif)

3. **调度**

**调度器**是内核中负责决定在特定时间应执行什么任务的部分。内核 可以在任务的生命周期内多次暂停并恢复该任务。 如果任务 B 取代任务 A 成为当前执行的任务 （即任务 A 暂停，任务 B 恢复），我们就可以称任务 A “换出”，任务 B “换入”。

**调度策略**是调度器用来决定何时执行哪个任务的算法。在（非实时）多用户系统中， 调度策略通常会确保每个任务获得“公平”的处理器时间。实时嵌入式系统中使用的策略详见下文。

只有当调度算法决定执行不同的任务时，任务才会换出。这种切换可能在当前 执行的任务不知情的情况下发生，例如调度算法响应外部事件或定时器到期时； 还可能 发生在执行任务显式调用某个导致其**让出**、**休眠**（也称为**延迟**）或**阻塞**的 API 函数时。

如果某任务让出，调度算法可能会再次选择同一任务执行。如果某任务休眠， 则在指定的延迟时间到期前不可被选择。 同样，如果某任务阻塞， 则在特定事件发生（例如，数据到达 UART）或超时期满之前将不可被选择。

操作系统内核负责管理这些任务状态和转换， 确保根据调度算法和每个任务的当前状态在给定时间选择适当的任务执行。

4. **实时调度**

实时操作系统 (**RTOS**) 利用与通用（非实时）系统相同的原理来实现多任务处理， 但两者的目标截然不同。这一差异主要体现在调度策略上。实时嵌入式系统 旨在对现实世界的事件作出及时响应。这些事件通常有截止时间， 实时嵌入式系统必须在此之前响应，RTOS 调度策略必须确保遵守这些截止时间要求。

为在小型 RTOS（如 FreeRTOS）中实现这一目标，软件工程师必须为每个任务分配优先级。RTOS 的调度策略 就是确保能够执行的最高优先级任务获得处理时间。如果存在多个能够运行的同等最高优先级任务（既没有延迟也没有阻塞），则调度策略可以选择在这些任务之间“公平”地分配处理时间。

这种基本形式的实时调度并非万能，无法改变时间的快慢，应用程序编写者必须确保设定的时序约束在所选任务优先级安排下是可行的。

# FreeRTOS

学习[ FreeRTOS 官网 ](https://www.freertos.org/zh-cn-cmn-s "https://www.freertos.org/zh-cn-cmn-s")内容。

## 内核特性

[任务和协程](#任务和协程)
[队列、互斥锁和信号量](#队列、互斥锁和信号量)
[直达任务通知](#直达任务通知)
[流缓冲区和消息缓冲区](#流缓冲区和消息缓冲区)
[软件定时器](#软件定时器)
[事件组](#事件组)
[低功耗支持](#低功耗支持)
[运行时统计信息](#运行时统计信息)
[RTOS 追踪功能](#rtos-追踪功能)
[内存管理](#内存管理)
[阻塞多个 RTOS 对象](#阻塞多个-rtos-对象)
[延迟中断处理](#延迟中断处理)
[钩子函数](#钩子函数)
[对称多处理简介](#对称多处理简介)



### 任务和协程

#### “任务”的特点
1. 使用 RTOS 的实时应用程序可以构建为一组独立的任务。
2. 每个任务 在自己的上下文中执行，不会碰巧依赖于系统内的其他任务或 RTOS 调度器 本身。
3. 在任何时间点，应用程序中只能执行一个任务，实时 RTOS 调度器 负责决定应该执行哪个任务。
4. 因此 RTOS 调度器可能在应用程序执行过程中 反复启动并停止每个任务（换入并换出每个任务）。
5. 由于任务不了解 RTOS 调度器 的情况，实时 RTOS 调度器 须确保换入任务时，处理器的上下文（寄存器 值、堆栈内容等）与换出该任务时完全相同。 
6. 为实现这一点，每个任务都分配有自己的堆栈。换出任务时，执行上下文 被保存到该任务的堆栈中，以便以后再换入相同的任务时可以准确地恢复其执行上下文。

##### 任务总结
> 操作简单。
> 没有使用限制。
> 支持完全抢占式机制。
> 完全按优先顺序排列。
> 每个任务都保留自己的堆栈，从而提高 RAM 使用率。
> 如果使用抢占式机制，则必须谨慎考虑重入问题。

#### 协程”的特点
协程是为了在非常小型的设备上使用而实现的，但现在很少在实际情况中使用。 因此尽管没有计划从代码中删除协程，但也没有计划进一步开发 这些协程。

协程在概念上类似于任务，但有以下根本差异。

1.  堆栈使用
应用程序中的所有协程共用一个堆栈。与使用任务编写的类似应用程序相比，这样所需的 RAM 大大减少。 
2.  调度和优先级
协程间使用优先级协同调度，但可以包含在使用抢占式任务 的应用程序中。
4.  宏实现
协程是通过一组宏实现的。
5.  使用限制
减少 RAM 使用是以一些严格限制协程构造为代价的。

##### 协程总结
> 协程间共享堆栈导致 RAM 使用率大大降低。
> 协作操作减少了重入问题。
> 可以在不同架构间移植。
> 相对于其他协程完全优先，但如果混用协程和任务，那么总是会被任务抢占。
> 需要特别考虑堆栈不足的问题。
> 对 API 调用位置有限制。
> 只在协程间进行协作操作。

#### 任务概述

[任务状态](#任务状态)
[任务优先级](#任务优先级)
[实现（写入）任务](#实现-写入-任务)
[空闲任务](#空闲任务)
[空闲任务钩子函数](#空闲任务钩子函数)

#### 任务状态

任务可以存在于以下状态中：

- **运行**
当任务实际执行时，它被称为处于运行状态。任务当前正在使用处理器。 如果运行 RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。
    
- **准备就绪**
准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态）， 但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。
    
- **阻塞**
如果任务当前正在等待时间或外部事件，则该任务被认为处于阻塞状态。 例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态）， 直到延迟结束——一个时间事件。 任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量 事件。处于阻塞状态的任务通常有一个"超时"期， 超时后任务将被超时，并被解除阻塞， 即使该任务所等待的事件没有发生。“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。

- **挂起**
与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务 没有超时。相反，任务只有在分别通过 vTaskSuspend() 和 xTaskResume() API 调用明确命令时 才会进入或退出挂起状态。

![](https://www.freertos.org/media/2018/tskstate.gif) **有效任务状态转换**

#### 任务优先级

每个任务均被分配了从 0 到 ( configMAX_PRIORITIES - 1 ) 的优先级，其中 configMAX_PRIORITIES 定义为 FreeRTOSConfig.h。

如果正在使用的移植实现了使用“前导零计数”类指令的移植优化任务选择机制 （针对单一指令中的任务选择）而且 configUSE_PORT_OPTIMISED_TASK_SELECTION 在 FreeRTOSConfig.h 中设置为 1，则 configMAX_PRIORITIES 无法高于 32。在其他所有情况下， configMAX_PRIORITIES 可以取任何合理数值——但为了保证 RAM 的使用效率，应取 实际需要的最小值。

优先级数字小表示任务优先级低。**空闲任务**的优先级为零 (tskIDLE_PRIORITY)。

FreeRTOS 调度器可确保在就绪或运行**状态**下的任务始终 比同样处于就绪状态下的更低优先级任务先获得处理器 (CPU) 时间。 换句话来说，处于运行状态的任务始终是能够运行的最高优先级任务。

处于相同优先级的任务数量不限。如果 configUSE_TIME_SLICING 未经定义，或者如果 configUSE_TIME_SLICING 设置为 1，则具有相同优先级的若干就绪状态任务将 通过时间切片轮询调度方案共享可用的处理时间。

#### 实现（写入）任务

FreeRTOS 调度（单核、AMP 和 SMP）

本页简要概述的 FreeRTOS 调度算法适用于单核、非对称多核 (AMP) 和对称多核 (SMP) RTOS 配置。调度算法是决定 哪个 RTOS 任务应处于**运行状态**的软件程序。在任何给定时间，每个处理器核心只能有一个任务处于运行状态。在 AMP 中，每个处理器核心运行自身的 FreeRTOS 实例。在 SMP 中，存在一个实例 FreeRTOS，可以跨多核调度 RTOS 任务。

默认 RTOS 调度策略（单核）

FreeRTOS 默认使用固定优先级的抢占式 调度策略，对**同等优先级的任务**执行时间切片轮询调度：

-   “固定优先级”是指调度器不会永久更改任务的优先级， 但可能会因**优先级继承**而暂时提高任务的优先级。
    
-   “抢占式”是指调度器始终运行优先级最高且可运行的 RTOS 任务， 无论任务何时能够运行。例如， 如果中断服务程序 (ISR) 更改了优先级最高且可运行的任务， 调度器会停止当前正在运行的低优先级任务 并启动高优先级任务——即使这发生在同一个时间片内 。这种情况下可以说高优先级任务 “抢占”了低优先级任务。
    
-   “轮询调度”是指具有相同优先级的任务轮流进入运行状态。
    
-   “时间切片”是指调度器会在每个 tick 中断上在同等优先级任务之间进行切换， tick 中断之间的时间构成一个时间切片。（tick 中断是 RTOS 用来衡量时间的周期性中断。）
    
使用优先排序的抢占式调度器，避免任务饥饿

始终运行优先级最高且可运行的任务的一个后果是 从未进入**阻塞或挂起**状态的高优先级任务将永久性剥夺 所有更低优先级任务的任何执行时间。这就是通常最好创建事件驱动型任务的原因之一 。例如，如果一个高优先级任务正在等待一个事件，那么它就不应 处于该事件的循环（轮询）中，因为如果处于轮询中，它会一直运行，永远不进入“阻塞”或 “挂起”状态。相反，该任务应进入“阻塞”状态等待这一事件。该事件可以 通过某个FreeRTOS任务间通信和同步原语发送至任务。  收到事件后，优先级更高的任务会自动解除“阻塞”状态。这样低优先级 任务会运行，而高优先级任务会处于“阻塞”状态。

配置 RTOS 调度策略

以下 FreeRTOSConfig.h 设置更改了默认调度行为：

-   ```c
    configUSE_PREEMPTION
    ```
    
    如果 `configUSE_PREEMPTION` 为 0，则表示抢占已关闭， 而且只有当运行状态的任务进入“阻塞”或“挂起”状态， 或运行状态任务调用 `taskYIELD()`，或中断服务程序 (ISR) 手动请求上下文切换时，才会发生上下文切换。
   
-   ```c
    configUSE_TIME_SLICING
    ```
    如果 `configUSE_TIME_SLICING` 为 0，则表示时间切片已关闭， 因此调度器不会在每个 tick 中断上在同等优先级的任务之间切换。
    
FreeRTOS AMP 调度策略

使用 FreeRTOS 的非对称多处理 (AMP) 是指多核设备的每个核心都单独运行自己的 FreeRTOS 实例。这些 核心并不都需要具有相同架构， 但如果 FreeRTOS 实例之间需要进行通信，则需要共享一些内存。

每个核心都会运行自己的 FreeRTOS 实例， 因此任何给定核心上的调度算法与上文的单核系统调度算法完全相同 。您可以使用流缓冲区或消息缓冲区作为核间通信原语， 这样一来，一个核心上的任务可以进入“阻塞”状态， 以等待另一个核心发来的数据或事件。

FreeRTOS SMP 调度策略

使用 FreeRTOS 的对称多处理 (SMP) 指的是 [一个 FreeRTOS 实例可以跨多个处理器核心调度 RTOS 任务](https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/13-Symmetric-multiprocessing-introduction/)。 由于只有一个 FreeRTOS 实例在运行，一次只能使用 FreeRTOS 的一个移植， 因此每个核心必须具有相同的处理器架构并共用相同的内存空间。

FreeRTOS SMP 调度策略使用与单核调度策略相同的算法， 但与单核和 AMP 场景不同的是， SMP 在任何给定时间都会导致多个任务处于运行状态 （每个核心上都有一个运行状态的任务）。这意味着， 只有缺乏可运行的高优先级任务时，才会运行低优先级任务的假设不再成立 。要想了解其中的原因，请考虑一下， 若起初只有一个高优先级任务 和两个中等优先级任务处于 [“就绪”状态](https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/01-Tasks-and-co-routines/02-Task-states)，SMP 调度器会如何选择在双核微控制器上运行的任务。调度器需要选择两个任务，每个核心对应一个任务。  首先，高优先级任务是指可运行的最高优先级任务， 因此会选择将它用于第一个核心。这样就剩下了两个中等优先级的任务 作为可运行的最高优先级任务，因此会将它们用于第二个核心 。结果是高优先级和中等优先级的任务同时运行。

配置 SMP RTOS 调度策略

将为单核或 AMP RTOS 配置编写的代码移动到 SMP RTOS 配置，而且该代码依据的假设是：如果存在能够运行的较高优先级任务， 则较低优先级任务将不会运行时，可以使用以下配置选项。

-   ```c
    configRUN_MULTIPLE_PRIORITIES
    ```    
    如果    
    ```c
    configRUN_MULTIPLE_PRIORITIES
    ```
    
     在 
    
    ```c
    FreeRTOSConfig.h
    ```
    
     中设置为 0，则只有在多个任务具有相同优先级的情况下， 调度器才会同时运行多个任务。这可以修复基于下列假设编写的代码： 一次将只运行一个任务，但同时必须牺牲 SMP 配置带来的一些好处。
    
-   ```c
    configUSE_CORE_AFFINITY
    ```
    
    如果 
    
    ```c
    configUSE_CORE_AFFINITY
    ```
    
     在 
    
    ```c
    FreeRTOSConfig.h
    ```
    
     中设置为 1， 则 
    
    ```c
    vTaskCoreAffinitySet()
    ```
    
     API 函数可用于定义某个任务可以在哪些核心上运行 以及不可以在哪些核心上运行。使用该方法，应用程序编写者可以防止 同时执行假设了自身执行顺序的两个任务 。

#### 空闲任务
#### 空闲任务钩子函数


### 队列、互斥锁和信号量
### 直达任务通知
### 流缓冲区和消息缓冲区
### 软件定时器
### 事件组
### 低功耗支持
### 运行时统计信息
### RTOS 追踪功能
### 内存管理
### 阻塞多个 RTOS 对象
### 延迟中断处理
### 钩子函数
### 对称多处理简介












