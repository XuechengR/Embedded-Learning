# Real-Time OS
实时操作系统（Real-Time Operating System，RTOS）是一种专门设计用于在严格的时间约束下执行任务的操作系统。它的核心特点是**实时性**，即确保任务在规定的时间内完成，而不会出现长时间的延迟。

- 实时操作系统的分类
1. 硬实时操作系统：必须保证所有任务在严格的时间限制内完成，否则可能会导致系统故障。例如，航空航天、医疗设备和工业控制系统。
2. 软实时操作系统：尽量保证任务在规定时间内完成，但偶尔的延迟不会导致系统崩溃。例如，视频流处理和在线游戏。

- 实时操作系统的特点
1. 任务调度：采用抢占式调度或时间触发调度，确保高优先级任务能够及时执行。
2. 低延迟：减少任务切换时间，提高系统响应速度。
3. 确定性：任务执行时间可预测，避免不确定性影响系统稳定性。
4. 资源管理：高效管理 CPU、内存和 I/O 设备，确保关键任务优先执行。

- 常见的实时操作系统
1. [FreeRTOS](#freertos)：开源、轻量级，适用于嵌入式系统。
2. VxWorks：广泛应用于航空航天和工业自动化领域。
3. RT-Thread：国产 RTOS，适用于物联网设备。
4. QNX：用于汽车、医疗和工业控制系统。
5. μC/OS-II：适用于小型嵌入式系统，代码精简。

## FreeRTOS

学习[FreeRTOS官网](https://www.freertos.org/zh-cn-cmn-s "https://www.freertos.org/zh-cn-cmn-s")内容。

### 1. 什么是通用操作系统？
操作系统是支持计算机基本功能的计算机程序， 为在计算机上运行的程序（或_应用程序_）提供服务。应用程序提供计算机用户 想要或需要的功能。操作系统提供的服务使得应用程序写入更快、更简单、 并且更易于维护。如果您正在阅读此网页，说明您正在使用网络浏览器（提供您感兴趣的功能的应用程序），该浏览器本身会在操作系统提供的环境中运行 。

### 2. 什么是 RTOS？
大多数操作系统似乎能同时执行多个程序。这称为多任务处理。实际上， 每个处理器内核在任何给定时间点都只能运行一个执行线程。操作系统中 一个名为调度器的部分负责决定何时运行哪个程序， 并通过在每个程序之间快速切换以造成同时执行的假象。

操作系统的类型取决于调度器如何决定何时运行哪个程序。例如， 多用户操作系统（如 Unix）中使用的调度器将确保每个用户都能获得合理的处理时间 。再比如，桌面操作系统（如 Windows）中的调度器会努力确保计算机对用户作出响应。 （注意：FreeRTOS 并非大型操作系统，也不是为在台式 计算机级处理器上运行而设计的，我使用这些例子纯粹是因为它们是读者熟悉的系统。）

实时操作系统中的调度器旨在提供 可预测的（通常描述为 _确定性_）执行模式。这对嵌入式系统而言意义重大，因为嵌入式系统 经常有实时要求。实时要求是指定嵌入式系统 必须在严格定义的时间内（_截止时间_）响应某个事件。只有当操作系统调度器的行为 可以预测（因此具有确定性）时， 才能保证满足实时要求。

传统的小型实时调度器（如 FreeRTOS 中使用的调度器） 通过允许用户为每个执行线程分配优先级来实现确定性。然后，调度器根据优先级来判断 下一个要运行的执行线程。在 FreeRTOS 中，执行线程称为 _任务_。

### 3. RTOS 基础知识
实时操作系统 (RTOS) 是一种体积小巧、确定性强的计算机操作系统。 RTOS 通常用于需要在严格时间限制内对外部事件做出反应的嵌入式系统，如医疗设备和汽车电子控制单元 (ECU)。 通常，此类嵌入式系统中只有一两项功能需要确定性时序，即使嵌入式系统不需要严格的实时反应，使用 RTOS 仍能提供诸多优势。

RTOS 通常比通用操作系统体积更小、重量更轻，因此 RTOS 非常适用于 内存、计算和功率受限的设备。

#### 多任务处理
**内核**是操作系统的核心组件。Linux 等通用操作系统采用的内核 允许多个用户看似同时访问计算机的处理器。这些用户可以各自执行多个程序，看起来像是并发运行。

每个执行的程序由操作系统控制下的一个或多个**线程**实现。如果操作系统能够以这种方式执行多个线程，则称为**多任务处理**。 像 FreeRTOS 这样的小型 RTOS 通常将线程称为**任务**，因为它们不支持虚拟内存，因此进程和线程之间没有区别。

使用多任务操作系统可以简化原本复杂的软件应用程序的设计：
- 操作系统的多任务处理和任务间通信功能允许将复杂的应用程序 划分为一组更小且更易于管理的任务。
- 这种划分可以简化软件测试，确保团队分工明确，并促进代码复用。
- 复杂的时序和排序细节将由 RTOS 内核负责，从而减轻了应用程序代码的负担。

#### 多任务处理与并发
常规单核处理器一次只能执行一个任务，但多任务操作系统可以快速切换任务， 使所有任务**看起来**像是同时在执行。下图展示了 三个任务相对于时间的执行模式。任务名称用不同颜色标示，并写在左侧。时间从左向右移动， 彩色线条显示在特定时间执行的任务。上方展示了所感知的并发执行模式， 下方展示了实际的多任务执行模式。

![TaskExecution.gif](https://www.freertos.org/media/2018/TaskExecution.gif)

#### 调度
**调度器**是内核中负责决定在特定时间应执行什么任务的部分。内核 可以在任务的生命周期内多次暂停并恢复该任务。 如果任务 B 取代任务 A 成为当前执行的任务 （即任务 A 暂停，任务 B 恢复），我们就可以称任务 A “换出”，任务 B “换入”。

**调度策略**是调度器用来决定何时执行哪个任务的算法。在（非实时）多用户系统中， 调度策略通常会确保每个任务获得“公平”的处理器时间。实时嵌入式系统中使用的策略详见下文。

只有当调度算法决定执行不同的任务时，任务才会换出。这种切换可能在当前 执行的任务不知情的情况下发生，例如调度算法响应外部事件或定时器到期时； 还可能 发生在执行任务显式调用某个导致其**让出**、**休眠**（也称为**延迟**）或**阻塞**的 API 函数时。

如果某任务让出，调度算法可能会再次选择同一任务执行。如果某任务休眠， 则在指定的延迟时间到期前不可被选择。 同样，如果某任务阻塞， 则在特定事件发生（例如，数据到达 UART）或超时期满之前将不可被选择。

操作系统内核负责管理这些任务状态和转换， 确保根据调度算法和每个任务的当前状态在给定时间选择适当的任务执行。

#### 实时调度
实时操作系统 (**RTOS**) 利用与通用（非实时）系统相同的原理来实现多任务处理， 但两者的目标截然不同。这一差异主要体现在调度策略上。实时嵌入式系统 旨在对现实世界的事件作出及时响应。这些事件通常有截止时间， 实时嵌入式系统必须在此之前响应，RTOS 调度策略必须确保遵守这些截止时间要求。

为在小型 RTOS（如 FreeRTOS）中实现这一目标，软件工程师必须为每个任务分配优先级。RTOS 的调度策略 就是确保能够执行的最高优先级任务获得处理时间。如果存在多个能够运行的同等最高优先级任务（既没有延迟也没有阻塞），则调度策略可以选择在这些任务之间“公平”地分配处理时间。

这种基本形式的实时调度并非万能，无法改变时间的快慢，应用程序编写者必须确保设定的时序约束在所选任务优先级安排下是可行的。


### 4. 内核特性

#### 4.1 任务和协程

##### 4.1.1 “任务”的特点

**简而言之**：使用 RTOS 的实时应用程序可以构建为一组独立的任务。每个任务 在自己的上下文中执行，不会碰巧依赖于系统内的其他任务或 RTOS 调度器 本身。在任何时间点，应用程序中只能执行一个任务，实时 RTOS 调度器 负责决定应该执行哪个任务。因此 RTOS 调度器可能在应用程序执行过程中 反复启动并停止每个任务（换入并换出每个任务）。由于任务不了解 RTOS 调度器的 情况，实时 RTOS 调度器须确保换入任务时，处理器的上下文（寄存器 值、堆栈内容等）与换出该任务时完全相同。 为实现这一点，每个任务都分配有自己的堆栈。换出任务时，执行上下文 被保存到该任务的堆栈中，以便以后再换入相同的任务时可以准确地恢复其执行上下文。

##### 4.1.2 任务状态

任务可以存在于以下状态中：

-   **运行**
    
    当任务实际执行时，它被称为处于运行状态。任务当前正在使用处理器。 如果运行 RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。
    
-   **准备就绪**
    
    准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态）， 但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。
    
-   **阻塞**
    
    如果任务当前正在等待时间或外部事件，则该任务被认为处于阻塞状态。 例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态）， 直到延迟结束——一个时间事件。 任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量 事件。处于阻塞状态的任务通常有一个"超时"期， 超时后任务将被超时，并被解除阻塞， 即使该任务所等待的事件没有发生。“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。
    
-   **挂起**
    
    与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务 没有超时。相反，任务只有在分别通过 vTaskSuspend() 和 xTaskResume() API 调用明确命令时 才会进入或退出挂起状态。
    

![](https://www.freertos.org/media/2018/tskstate.gif)**有效任务状态转换**










