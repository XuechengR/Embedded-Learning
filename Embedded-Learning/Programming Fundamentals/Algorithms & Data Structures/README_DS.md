### Algorithms & Data Structures
学习书籍《[Hello 算法](https://www.hello-algo.com/ "https://www.hello-algo.com/")》

1. [初始算法](#初始算法)
2. [复杂度分析](#复杂度分析)
3. [数据结构](#数据结构)
4. [数组与链表](#数组与链表)
5. [栈和队列](#栈和队列)
6. [哈希表](#哈希表)
7. [树](#树)
8. [堆](#堆)
9. [图](#图)
10. [搜索](#搜索)
11. [排序](#排序)
12. [分治](#分治)
13. [回溯](#回溯)
14. [动态规划](#动态规划)
15. [贪心](#贪心)

#### 初始算法

**算法**（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤。

> 问题是明确的，包含清晰的输入和输出定义。
> 具有可行性，能够在有限步骤、时间和内存空间下完成。
> 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。

**数据结构**（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法。

> 空间占用尽量少，以节省计算机内存。
> 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。
> 提供简洁的数据表示和逻辑信息，以便算法高效运行。

#### 2. 复杂度分析

渐近复杂度分析（asymptotic complexity analysis），简称**复杂度分析**。
它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长**趋势**。

**时间复杂度**（time complexity）：用于衡量算法运行时间随数据量增长的趋势。
> $O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n) < O(n!)$  
> 常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 指数阶 &lt; 阶乘阶

**空间复杂度**（space complexity）用于衡量算法占用内存空间随数据量增长的趋势。
> $O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n)$  
> 常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 平方阶 &lt; 指数阶  
> **通常只关注最差空间复杂度**

#### 数据结构

- ##### 数据结构分类
逻辑结构：**线性**和**非线性**。
> 线性数据结构：**数组**、**链表**、**栈**、**队列**、**哈希表**，元素之间是**一对一**的顺序关系。
> 非线性数据结构：树、堆、图、哈希表。
> 
> 非线性数据结构可以进一步划分为**树形结构**和**网状结构**。
>> 树形结构：**树、堆、哈希表**，元素之间是**一对多**的关系。
>> 网状结构：**图**，元素之间是**多对多**的关系。

物理结构：连续与分散。

- ##### 基本数据类型

> 一个二进制位即为 1 比特。
> 1 字节（byte）由 8 比特（bit）组成。

基本数据类型是 CPU 可以直接进行运算的类型，以二进制的形式存储在计算机中。

|类型|||
|-|-|-|
|整数类型| `byte`、`short`、`int`、`long`| |
|浮点数类型| `float`、`double`| 表示小数|
|字符类型| `char`| 表示字母、标点符号、表情符号|
|布尔类型| `bool`| 表示“是”与“否”判断|

- ##### 原码、反码和补码
  数字是以“补码“的形式存储在计算机中的。（补码 $10000000$ 代表 $−128$）

1. 原码（sign-magnitude）：二进制表示的最高位为符号位，其中 $0$ 表正，$1$ 表负，其余位表示数字的值。
2. 反码（1's complement）：正数的反码与其原码相同，负数的反码是对其**原码除符号位外的所有位取反**。（负数的原码不能直接用于运算，因此引入反码）
3. 补码（2's complement）：正数的补码与其原码相同，负数的补码是在其**反码的基础上加 1** 。（数字零的原码有 $+0$ 和 $−0$ 两种表示方式，与原码一样，反码也存在正负零歧义问题，因此引入了补码）

#### 数组与链表

- ##### 数组
数组（array）是一种线性数据结构，其**将相同类型的元素存储在连续的内存空间**中。我们将元素在数组中的位置称为该元素的索引（index）。

初始化，访问元素，插入元素，删除元素，遍历数组，查找元素，扩容数组
```c
/* 初始化数组 */
int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }
int nums[5] = { 1, 3, 2, 5, 4 };
```
```c
/* 随机访问元素 */
int randomAccess(int *nums, int size) {
    // 在区间 [0, size) 中随机抽取一个数字
    int randomIndex = rand() % size;
    // 获取并返回随机元素
    int randomNum = nums[randomIndex];
    return randomNum;
}
```

- ##### 链表
链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。

链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。

初始化链表，插入节点，删除节点，访问节点，查找节点
```c
/* 链表节点结构体 */
typedef struct ListNode {
    int val;               // 节点值
    struct ListNode *next; // 指向下一节点的指针
} ListNode;

/* 构造函数 */
ListNode *newListNode(int val) {
    ListNode *node;
    node = (ListNode *) malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}
```

#### 5. 栈和队列
- ##### 栈
```c
栈（stack）是一种遵循先入后出逻辑的线性数据结构。
/* 基于链表实现的栈 */
typedef struct {
    ListNode *top; // 将头节点作为栈顶
    int size;      // 栈的长度
} LinkedListStack;

/* 构造函数 */
LinkedListStack *newLinkedListStack() {
    LinkedListStack *s = malloc(sizeof(LinkedListStack));
    s->top = NULL;
    s->size = 0;
    return s;
}
```

- ##### 队列

#### 哈希表
#### 树
#### 堆
#### 图
#### 搜索
#### 排序
#### 分治
#### 回溯
#### 动态规划
#### 贪心